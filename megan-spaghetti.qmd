---
title: "megan-spaghetti"
format: html
---

load libraries
```{r}
library(tidyverse)
library(janitor)
library(dplyr)
library(terra)
#library(tmap)
library(sf)
library(here)
library(stars)
library(spData)
library(terra)
library(readxl)
```

Download data 
```{r}
current_dams <- read_sf("../data/GRanD_Version_1_3") %>% 
  clean_names()

future_dams <- read_csv("../data/FHReD_2015_future_dams/FHReD_2015_future_dams_Zarfl_et_al_beta_version.csv") %>% 
  clean_names()

# Water Basin
basin_level3 <- read_sf("../data/hybas_as_lev01-12_v1c/hybas_as_lev03_v1c.shp") %>% 
  clean_names()

# Rivers
asia_rivers <- read_sf("../data/HydroRIVERS_v10_as.gdb") %>% 
  clean_names()
```
# Clean data & Crop to Nepal 

```{r}
# Make future dams df spatial 
future_dams <- st_as_sf(future_dams,
         coords = c('lon_cleaned', 'lat_cleaned'), 
         crs = st_crs(current_dams))

# Filter water basin to Nepal Level 
nepal_basin <- basin_level3 %>% 
  filter(hybas_id == 4030025450)

# Filter rivers to order 3 
asia_rivers3 <- asia_rivers %>% 
  filter(ord_clas == 3)

# Make geometeries valid 
current_dams <- st_make_valid(current_dams)
future_dams <- st_make_valid(future_dams)
nepal_basin <- st_make_valid(nepal_basin)

# Crop dams and rivers to Nepal 
nepal_current_dams <- st_intersection(nepal_basin, current_dams)
nepal_future_dams <- st_intersection(nepal_basin, future_dams)
nepal_rivers <- asia_rivers3 %>%
  st_filter(y = nepal_basin, .predicate = st_intersects)


rm(list = c('asia_rivers', 'asia_rivers3', 'current_dams', 'future_dams'))

```

# Cropping to 1 river with multiple dams on it

```{r}
# Creating bounding box of 1 river
box_poly <- st_as_sfc(
  st_bbox(c(xmin = 83.56, xmax = 83.6987, ymin = 28.328360, ymax = 28.704314), 
          crs = st_crs(nepal_basin)))

# Check CRS 
st_crs(nepal_basin) == st_crs(box_poly)

# Map everything 
tm_shape(nepal_basin) + 
  tm_polygons(fill_alpha = 0.4, lwd = 2.5) + 
  tm_basemap('Esri.WorldTopoMap') + 
  tm_shape(nepal_current_dams) + 
  tm_dots(fill = "red") + 
  tm_shape(nepal_future_dams) + 
  tm_dots(fill = "blue") + 
  tm_shape(nepal_rivers) + 
  tm_lines() + 
  tm_add_legend(type = "polygons", 
                labels = c("Current Dams", "Future Dams"), 
                fill = c("red", "blue"), 
                title = "Dam Status") + 
  tm_title(text = "Dams in Nepal") + 
  tm_shape(box_poly) + 
  tm_borders(lwd =2, col = "goldenrod")+ 
  tm_compass() + 
  tm_scalebar() 

# Crop to bounding box 
trial_current_dams <- st_intersection(box_poly, nepal_current_dams)
trial_future_dams <- st_intersection(box_poly, nepal_future_dams)
trial_river <- nepal_rivers %>%
  st_filter(y = box_poly, .predicate = st_intersects)

# Map new crop 
tm_shape(trial_future_dams) + 
  tm_dots(fill = "blue") + 
  tm_shape(trial_river) +
  tm_lines() +
  tm_basemap('Esri.WorldTopoMap')

# ----------------------------------------------------- 

# Select 2 dams on the river 
trial_future_dams_sf <- st_sf(trial_future_dams)
dam1 <- trial_future_dams_sf[1,]
dam2 <- trial_future_dams_sf[2,]

tm_shape(trial_river) +
  tm_lines() +
  tm_basemap('Esri.WorldTopoMap') + 
  tm_shape(dam1) + 
  tm_dots(fill = "blue") + 
  tm_shape(dam2) + 
  tm_dots(fill = "purple")

dam_points <- rbind(dam1, dam2)
dam_points <- data.frame(dam_points)
dam_points <- st_as_sf(dam_points, crs = 'EPSG:4326') # make sf 

```

# Finding the distance between dams on this river

## Clean data up

```{r}
# make sure sf 
#trial_future_dams <- st_as_sf(trial_future_dams)

# force all crs 
dam_points <- st_transform(dam_points, crs = 3857)
trial_future_dams <- st_transform(trial_future_dams, crs = 3857)
trial_river <- st_transform(trial_river, crs = 3857)
#trial_river_union <- st_transform(trial_river_union, crs = 3857)

# Check them 
st_crs(trial_river) == st_crs(trial_future_dams)
st_crs(dam_points) == st_crs(trial_future_dams)

# unionize river ? 
trial_river_union <- st_union(trial_river)

# Check classes 
class(trial_river)
class(trial_future_dams)
class(trial_river_union)
class(dam_points)

# Make all valid 
trial_future_dams <- st_make_valid(trial_future_dams)
trial_river <- st_make_valid(trial_river)
trial_river_union <- st_make_valid(trial_river_union)
```


Find total length of River 
```{r}
# total length of the line 
st_length(trial_river) 
st_length(trial_river_union) 
```

Snap Point to River

```{r}
snapped_points <- st_snap(dam_points, trial_river, tolerance = 50)
```

## Finding distance with `riverdist` 

`riverdistancemat()` returns a matrix of network distances between all observations in a dataset.

```{r}
library(riverdist)

# shape col => 'geometry' (need for line2networl)
trial_river <- st_set_geometry(trial_river, "geometry") 
# Make the river a river network 
trial_river_network <- line2network(sf = trial_river, reproject = 'EPSG:32644')

# Getting vectors of x and y 
trial_future_dams_proj <- st_transform(trial_future_dams, 32644)
coords_matrix <- st_coordinates(trial_future_dams_proj)
x <- coords_matrix[ ,'X']
y <- coords_matrix[ ,'Y']

# Snap points to the river 
xy_line <- xy2segvert(x = x, y = y, rivers = trial_river_network)

# Find distance between points
dist_mat <- riverdistancemat(vert = xy_line$vert, 
                 seg = xy_line$seg,
                 rivers = trial_river_network)
dist_mat
```

**Results:**

-   row and column = dam (distance from itself is 0)

    -   row 1 and column 1 = dam 1

    -   row 2 and column 2 = dam 2

-   off-diagonal entries = river HYDROLOGICAL /NETWORK distance

    -   Distance from dam 1 to dam 2 = 110315 m

```{r}
library(tmap)

tm_shape(nepal_current_dams) + 
  tm_dots(fill = "blue") + 
  tm_shape(nepal_future_dams) + 
  tm_dots(fill = "red")


tm_shape(current_dams) + 
  tm_dots(fill = "red") + 
  tm_shape(future_dams) + 
  tm_dots(fill = "blue") + 
  tm_basemap("Esri.OceanBasemap")


```

```{r}


  
basin <- basin_level3 %>% 
    filter(hybas_id == 4030039450) # 4030025450 is nepals [need to make this more user friendly later]
  

basin <- st_make_valid(basin) # Make geometries valid  
  

  # Filter river for order the 3+ 
river <- rivers_global %>% 
    filter(ord_stra >= 3)
  
river <- st_make_valid(river) # Make geometries valid 
  
  # Crop river to basin polygon 
river <- river %>%
    st_filter(y = basin, .predicate = st_intersects)
  

  # Make sure river_network is LINESTRINGS (for sfnetwork)
  river <- st_cast(river, "LINESTRING")
  
  # ------------------- DAMS ------------------------------
  # Crop to basin 
  current_dams <- current_dams_global %>%
    st_filter(y = basin, .predicate = st_intersects)
  
  future_dams <- future_dams_global %>%
    st_filter(y = basin, .predicate = st_intersects)
  
  

  # Map check 
  # tm_shape(country_basin) +
  #   tm_polygons(fill_alpha = 0.4, lwd = 2.5) +
  #   tm_basemap('Esri.WorldTopoMap') +
  #   tm_shape(current_dams) +
  #   tm_dots(fill = "red") +
  #   tm_shape(future_dams) +
  #   tm_dots(fill = "blue") +
  #   tm_shape(river_network) +
  #   tm_lines() +
  #   tm_add_legend(
  #     type = "polygons",
  #     labels = c("Current Dams", "Future Dams"),
  #     fill = c("red", "blue"),
  #     title = "Dam Status"
  #   ) +
  #   tm_title(text = "Dams") +
  #   tm_compass() +
  #   tm_scalebar()
 
  
  
  
   ######### -------------------- CONNECTIVITY --------------------#########
  
  # ------------------- CREATE RIVER NETWORK ---------------------------
  
  net <- as_sfnetwork(river, direction = TRUE) %>% # convert river geom into spatial network
    tidygraph::activate("edges") %>%  # "Next operation applied to edges table (not node table)"
    mutate(weight = edge_length()) # calculate spatial length of each edge (river segment)
  
  net_df <- as_tibble(net) # makes sfnetwork a df 
  
  
  # CRS test 
  if (st_crs(current_dams) == st_crs(future_dams)) {
    print("Dam CRS match")
  } else {
    warning("Dam CRS do not match")
  }
  
  # Mark which nodes are dams (current vs future) before blending & select similar columns
  current_dams <- current_dams %>% 
    mutate(is_current_dam = TRUE) 
  
  future_dams <- future_dams %>% 
    mutate(is_current_dam = FALSE)  

  # Combine future and current dam dfs
  all_dams <- rbind(current_dams, future_dams)
  
  net_with_dams <- net %>% 
    st_network_blend(all_dams, tolerance = 1000)
  
  
  net_with_dams_df <- as_tibble(net_with_dams) # makes sfnetwork a df 

  
  # ------------------- CONNECTIVITY MATRIX --------------------------
  
  # Getting the current dam node ID 
  current_dam_nodes <- net_with_dams %>% 
    tidygraph::activate("nodes") %>% 
    mutate(node_id = row_number()) %>% # create new column with node ID
    as_tibble() %>% 
    filter(is_current_dam == TRUE) %>% 
    pull(node_id) # list of all dam nodes 
  
  # Getting the future dam node ID 
  future_dam_nodes <- net_with_dams %>% 
    tidygraph::activate("nodes") %>% 
    mutate(node_id = row_number()) %>% # create new column with node ID
    as_tibble() %>% 
    filter(is_current_dam == FALSE) %>% 
    pull(node_id) # list of all dam nodes 
  
  # Create connective matrix 
  connectivity_matrix  <- distances(  # library(igraph) - calculates shortest path 
    net_with_dams, 
    v = current_dam_nodes, # starting nodes 
    to = future_dam_nodes, # ending nodes - creates all pairwise combinations 
    weights = tidygraph::activate(net_with_dams, "edges") %>% # use river segment lengths to calculate shortest path 
      pull(weight), # extract the `weight` column
    mode = "out" # DIRECTIONAL CONNECTIVITY 
  )
  
  
  # ------------------- DATAFRAME --------------------------
  
  
  # Get dam nodes (current AND future)
  dam_nodes <- net_with_dams %>% 
    tidygraph::activate("nodes") %>% # activate nodes 
    mutate(node_id = row_number()) %>% # 
    as_tibble() %>% 
    filter(is_current_dam == TRUE | is_current_dam == FALSE) %>% 
    pull(node_id)
  
  # Get dam_id for each dam node directly from network
  dam_ids <- net_with_dams %>%
    tidygraph::activate("nodes") %>%
    as_tibble() %>%
    slice(dam_nodes) %>%
    pull(dam_id)
  
  # Create dam labels using full grand_id
  dam_labels <- paste0("Dam_", dam_ids)
  
  # Get number of dams (rows/columns in symmetric matrix)
  n_dams <- nrow(connectivity_matrix)
  
  # Create row indices for upper triangle: repeat 1, then 1,1, then 1,1,1, etc.
  row_idx <- rep(1:(n_dams-1), times = (n_dams-1):1)
  
  # Create column indices for upper triangle: 2:n, then 3:n, then 4:n, etc.
  col_idx <- unlist(lapply(2:n_dams, function(i) i:n_dams))
  
  # Extract distance values from matrix using row/column index pairs
  distances <- connectivity_matrix[cbind(row_idx, col_idx)]
  
  # Create dataframe with columns: from dam, to dam, and distance
  reach_df <- data.frame(
    from_dam = dam_labels[row_idx],           # Source dam label (hybas_id)
    to_dam = dam_labels[col_idx],             # Destination dam label (hybas_id)
    distance_m = distances,                   # Distance value in meters
    stringsAsFactors = FALSE                  # Keep character columns as character
  )
  
  # Count pairs with zero distance (dams at same network node)
  zero_pairs <- sum(reach_df$distance_m == 0, na.rm = TRUE)
  
  # Count pairs with duplicate distances (same distance value appears multiple times)
  duplicate_distances <- sum(duplicated(reach_df$distance_m[reach_df$distance_m > 0]))
  
  # Filter out zeros (dams at same location) and NA/Inf values (unreachable pairs)
  reach_df <- reach_df[reach_df$distance_m > 0 & !is.na(reach_df$distance_m) & is.finite(reach_df$distance_m), ]
  
  # Sort dataframe by distance column (ascending order)
  reach_df <- reach_df[order(reach_df$distance_m), ]
  
  reach_df
  

```

```{r}
tm_shape(nepal_current_dams) + 
  tm_dots(fill = "red") + 
  tm_shape(nepal_future_dams)+ 
  tm_dots(fill ="blue") + 
  tm_shape(nepal_rivers_3up) + 
  tm_lines()


```

